Problem:

https://leetcode.com/problems/redundant-connection/description/


Solution:

//Time Complexity: O(V.E)
//Space Complexity: O(V+E)

class Solution {
public:
    // Function to detect a cycle using BFS starting from a source node
    bool isCyclicBFS(int src, unordered_map<int, bool> &visited, unordered_map<int, list<int>> &adj, vector<int>& cycleEdge){
        unordered_map<int, int> parent; // Keeps track of the parent nodes
        parent[src] = -1; // Source node has no parent
        visited[src] = true; // Mark the source node as visited
        queue<int> q; // Queue for BFS
        q.push(src); // Push the source node to the queue

        // Perform BFS
        while(!q.empty()){
            int front = q.front(); // Get the front node from the queue
            q.pop(); // Remove the front node from the queue

            // Traverse all the neighbors of the current node
            for(auto neighbour: adj[front]){
                // If the neighbor is already visited and not the parent of the current node, a cycle is found
                if(visited[neighbour] && neighbour != parent[front]){
                    cycleEdge = {front, neighbour}; // Store the edge that forms the cycle
                    return true; // Return true indicating a cycle is found
                }
                // If the neighbor is not visited, continue the BFS
                else if(!visited[neighbour]){
                    q.push(neighbour); // Push the neighbor to the queue
                    visited[neighbour] = true; // Mark the neighbor as visited
                    parent[neighbour] = front; // Set the current node as the parent of the neighbor
                }
            }
        }
        return false; // Return false if no cycle is found
    }

    // Function to find the redundant connection
    vector<int> findRedundantConnection(vector<vector<int>>& edges) {
        int n = edges.size(); // Number of edges
        unordered_map<int, list<int>> adj; // Adjacency list to represent the graph
        vector<int> cycleEdge; // To store the edge that forms a cycle

        // Traverse through all the edges
        for(int i = 0; i < n; i++){
            int u = edges[i][0]; // First node of the edge
            int v = edges[i][1]; // Second node of the edge

            // Before adding the edge, check if it forms a cycle
            unordered_map<int, bool> visited; // Keep track of visited nodes
            adj[u].push_back(v); // Add the edge to the adjacency list
            adj[v].push_back(u);
            if(isCyclicBFS(u, visited, adj, cycleEdge)){ // Check if the added edge forms a cycle
                return {u, v}; // Return the redundant edge
            }
        }
        return {}; // Return an empty vector if no redundant edge is found
    }
};
